// Copyright (C) 2006 Alexander Ushakov
// Contents: Part of implementation of class TheGrigorchukGroupAlgorithms
// Algorithms for a normal subgroup generated by abab.
//
// Principal Authors: Alexander Ushakov
//
// Revision History:
//


#include "Word.h"
#include "TheGrigorchukGroupAlgorithms.h"


//---------------------------------------------------------------------------//
//----------------------- TheGrigorchukGroupAlgorithms ----------------------//
//---------------------------------------------------------------------------//


int TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( const Word& w )
{
  int b = 0;
  int s = 0;
  
  Word r = reduce( w );
  for( Word::const_iterator w_it=r.begin( ) ; w_it!=r.end( ) ; ++w_it ) {
    switch( *w_it ) {
    case 1:
      if( s%2==0 ) 
	s = (s+7)%8;
      else
	s = (s+1)%8;
      break;
    case 2:
      b = (b+1)%2;
      break;
    case 3: // = 2+4
      b = (b+1)%2;
    case 4:
      if( s%2==0 ) 
	s = (s+1)%8;
      else
	s = (s+7)%8;
      break;
    }
  }

  return 8*b + s;
}


//---------------------------------------------------------------------------//
//----------------------- TheGrigorchukGroupAlgorithms ----------------------//
//---------------------------------------------------------------------------//


Word TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( int c )
{
  Word result;
  int a = c%8;
  int b = c>=8 ? 1 : 0;
  if( c>=8 )
    result.push_back( 2 );
  if( a>=4 )
    for( int i=0 ; i<8-a ; ++i )
      push_back( result , i%2==0 ? 1 : 4 );
  else
    for( int i=0 ; i<a ; ++i )
      push_back( result , i%2==0 ? 4 : 1 );
  
  return result;
}


//---------------------------------------------------------------------------//
//----------------------------- liftPairKcosetsUP ---------------------------//
//---------------------------------------------------------------------------//


int TheGrigorchukGroupAlgorithms::liftPairKcosetsUP( int x , int y )
{
  int result;
  static map< pair< int , int > , int > liftTable;
  if( liftTable.size( )==0 )
    liftTable = KCosetLiftTable( );
  
  map< pair< int , int > , int >::const_iterator l_it = liftTable.find( pair< int , int >(x,y) );
  if( l_it==liftTable.end( ) )
    return -1;
  
  return (*l_it).second;
}


//---------------------------------------------------------------------------//
//----------------------------- liftPairsKcosetsUP --------------------------//
//---------------------------------------------------------------------------//


set< int > TheGrigorchukGroupAlgorithms::liftPairsKcosetsUP( const set< int >& K1 , const set< int >& K2 )
{
  set< int > result;
  
  for( set< int >::const_iterator K1_it=K1.begin( ) ; K1_it!=K1.end( ) ; ++K1_it ) {
    for( set< int >::const_iterator K2_it=K2.begin( ) ; K2_it!=K2.end( ) ; ++K2_it ) {
      int l = liftPairKcosetsUP( *K1_it , *K2_it );
      if( l!=-1 )
	result.insert( l);
    }
  }
  
  return result;
}


//---------------------------------------------------------------------------//
//------------------------------ KCosetLiftTable ----------------------------//
//---------------------------------------------------------------------------//


map< pair< int , int > , int > TheGrigorchukGroupAlgorithms::KCosetLiftTable( )
{
  typedef pair< int , int > PII;
  map< PII , int > preimages;
  
  // Generators of K:
  Word G[3];
  G[0] = (Word(1)*Word(2)).power(2);
  G[1] = (Word(2)*Word(1)*Word(4)*Word(1)).power(2);
  G[2] = (Word(1)*Word(2)*Word(1)*Word(4)).power(2);
  
  // A. Consider 8 of 16 representatives belonging to ST(1)
  for( int b=0 ; b<=1 ; ++b ) {
    for( int a=0 ; a<=3 ; a+=2 ) {
      for( int d=0 ; d<=1 ; ++d ) {

	Word representative = TheGrigorchukGroupAlgorithms::reduce( Word(2).power(b) * (Word(4)*Word(1)).power(a) * Word(4).power(d) );
	
	pair< Word , Word > S = TheGrigorchukGroupAlgorithms::split( representative );
	int n  = TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( representative );
	int n1 = TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( S.first );
	int n2 = TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( S.second );
	// cout << "(" << n1 << " , " << n2 << ") -> " << n << endl;
	
	// now starting from (n1,n2) compute the image of the coset C r -> (C r1, C r2)
	map< PII , Word > I;
	map< PII , Word > I2;
	preimages[PII(n1,n2)] = n;
	I2[PII(n1,n2)] = representative;
	while( !I2.empty( ) ) {
	  
	  pair< PII , Word > P = *I2.begin( );
	  I2.erase( I2.begin( ) );
	  I[P.first] = P.second;
	  
	  for( int i=0 ; i<3 ; ++i ) {
	    Word nw = P.second * G[i];
	    pair< Word , Word > S = TheGrigorchukGroupAlgorithms::split( nw );
	    int nw1 = TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( S.first );
	    int nw2 = TheGrigorchukGroupAlgorithms::cosetRepresentativeKSbgp( S.second );
	    
	    if( I.find(PII(nw1,nw2))==I.end( ) && I2.find(PII(nw1,nw2))==I2.end( ) ) {
	      
	      // cout << "(" << nw1 << " , " << nw2 << ") -> " << n << endl;
	      I2[PII(nw1,nw2)] = nw;
	      preimages[PII(nw1,nw2)] = n;
	    }
	  }
	}
      }
    }
  }
  
  return preimages;
}
